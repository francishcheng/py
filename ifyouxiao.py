#!/usr/bin/env python
# coding: utf-8

# In[1]:


import xlrd
import os
import xlwt
import copy
import pandas as pd
import csv
import sys
import numpy as np
import time
from sklearn.datasets import make_blobs
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt


# In[2]:



def judge_youxiao(sj, C_ygz, Ce):
# In[3]:

    sj = [int(i) for i in sj.split(',')[:-1]]
    sj = np.array(sj)
    sj = sj.T

    C_ygz=np.array([C_ygz])   ; #荧光值
    Ce=np.array([Ce])      ;#项目号

    sj_hang = len(sj)   #350个数据点
    sj_lie = 1 #数据条目数,1条
    reason=np.zeros((sj_lie,9))  #判定


    # In[4]:


    ##与matlab变量名保持一致
    curve2=sj
    curve2_lie=sj_lie
    curve2_hang=sj_hang
    yssj=np.array(sj.T)#原始数据
    del sj
    del sj_lie
    del sj_hang#删除变量，释放缓存


    # In[5]:


    # 曲线数据光滑化,先光滑再归一化
    from scipy.signal import savgol_filter
    a = curve2
    curve2=savgol_filter(a,5,4)


    # In[6]:


    ##数据的归一化处理
    time_start = time.time() #开始计时
    curveToOne2=np.zeros((curve2_lie,curve2_hang))

    for i in range (curve2_lie):
        
        zxz=min(curve2);
        zdz=max(curve2);
        
        for j in range (curve2_hang):
            fenmu=(zdz-zxz)
            
            if fenmu==0:
                fenmu=0.1
            
            curveToOne2[i][j]=(curve2[j]-zxz)/fenmu
    #转置
    curveToOne2= curveToOne2.T


    # In[7]:


    ##ce 的计算
    xiangmuhao=[0,0,1,1,1,5,3,1,1,1,1,2,1,0,0,1,1,1,1,1,1,1,1,1,2]

    ce=np.zeros(curve2_lie);#一维，且值都为1

    for i in range (curve2_lie):
        p=Ce[i]
        if (Ce[i]==33) or (Ce[i]==48)or (Ce[i]==49)or (Ce[i]==50)or (Ce[i]>24):
            p=3
            Ce[i]=p
        
        x=xiangmuhao[(p)] 
        ce[i]=x
        if (Ce[i]!=0) &(Ce[i]!=1) &(Ce[i]!=13) &(Ce[i]!=14):
            reason[i][8]=1  #第九条无效判定标准，测试项目错误     


    # In[8]:


    ## 输入C、T1~T3参考值，从小到大输入！！
    ck=np.array([[190,290,0,0],[115,200,280,0],[67,146,217,294],[125,245,0,0],[65,180,305,0]])-1;# 4:老的单测;5:新三测
    sit_C=np.array([1,3,4,1,3]);     # C的位置


    # In[9]:


    ##记录峰的出现位置f，判断峰的个数F
    error=[];
    bd=6;  #区间波动
    ad=[curveToOne2[curve2_hang-1]]
    for i in range (bd*2):#矩阵扩展
        curveToOne2=np.r_[curveToOne2, ad]
    h1=0.0025;  #峰区域的阈值 
    h2=0.01; #非峰区域的阈值
    f=np.zeros((len(curveToOne2),len(curveToOne2[1])));
    H=np.zeros((len(curveToOne2),len(curveToOne2[1])));
    F=np.zeros((len(curveToOne2[1]),2));


    # In[10]:


    ##波峰判别（波峰矫正）
    for j in range (curve2_lie):
        for i in range(bd,curve2_hang+bd):    
            ## 确定峰判断标准
            h=h2; #高标准状态为非峰区域时候        
            p=ce[j]-1

                
            for ii in range (int(p)):
                if (ck[int(p)][ii]-30<=i) & (i<=ck[int(p)][ii]+30):  #i:处于参考峰区域时候，采用低标准
                    h=h1;
            H[i][j]=h;
            
            ## 顶峰判断
            if (curveToOne2[i][j]>(curveToOne2[i-bd][j]+H[i][j])) & (curveToOne2[i][j]>(curveToOne2[i+bd][j]+H[i][j])) & ((curveToOne2[i-1][j]<=curveToOne2[i][j])):
                f[i][j]=1;
                f[i-1][j]=0;  
                
            ## 尾巴处理   
            if i>330:
                f[i][j]=0;

                
        #判断是不是老单测标准    
        if ce[j]==1:
            findfind=f[:,j];
            if sum(f[:,j])>=2:
                sitfindfind=np.argwhere(findfind)
                if (abs(sitfindfind[0]-ck[3][0])<20) or (abs(sitfindfind[1]-ck[3][1])<20):
                    ce[j]=4;
            if sum(f[:,j])==1:
                sitfindfind=np.argwhere(findfind)
                if (abs(sitfindfind[0]-ck[3][0])<20):
                    ce[j]=4;                  
        #判断是不是新2测标准    
        if ce[j]==2:
            findfind=f[:,j];                       
            if sum(f[:,j])>=1:
                sitfindfind=np.argwhere(findfind)
                if (abs(sitfindfind[0]-ck[4][0])<30):
                    ce[j]=5;
        #判断是不是新2测标准    
        if ce[j]==5:
            findfind=f[:,j];                       
            if sum(f[:,j])>=1:
                sitfindfind=np.argwhere(findfind)
                if (abs(sitfindfind[0]-ck[1][0])<30):
                    ce[j]=2;       
        
        
        ## 头处理
        f[0:20,j]=0; 


            
    ## 结果统计
        F[j][0]=sum(f[:,j]);   #峰的个数
    


    # In[11]:


    ## 删除扩展的行 
    for i in range (bd*2):
        curveToOne2 = np.delete(curveToOne2, curve2_hang+bd*2-i-1, 0)  
        f= np.delete(f, curve2_hang+bd*2-i-1, 0)
        H= np.delete(H, curve2_hang+bd*2-i-1, 0)


    # In[12]:


    ff=np.zeros((curve2_lie,4));#记录四个位点是否有峰
    sit=np.zeros((curve2_lie,7)); #最大的合适峰数，要么为单测=2，要么三侧=4

    for j in range (curve2_lie):
        if F[j][0]<=7: #一定要小于等于7个峰 才执行
            k=0
            for i in range (curve2_hang):
                if f[i][j]==1:    
                    sit[j][k] = i 
                    k=k+1;

    sitc=np.zeros((len(curveToOne2[1]),1));

    for j in range (curve2_lie):
        p=F[j][0]
        if F[j][0]>7:
            p=7
        for m in range (int(p)-2):
            if (sit[j][m]!=0)&(sit[j][m+1]!=0)&(sit[j][m+2]!=0):
                if  (abs(sit[j][m]-sit[j][m+1])<=50)&(abs(sit[j][m+1]-sit[j][m+2])<=50):
                    sit[j][m+1]=0 


    for j in range (curve2_lie):
        p=F[j][0]
        if F[j][0]>7:
            p=7
        for m in range (int(p)): #单双三测 判断C、T1~T3位点是否有峰
            if  (ce[j]==1)&(sit[j][m]!=0):
                for x in range (4):
                    if  (abs(sit[j][m]-ck[0][x])<=20):
                        ff[j][x]=1;  #记录位点m是否出现峰
                        if x==0:
                            sitc[j]=sit[j][m]#记录C线峰坐标
            if  (ce[j]==2)&(sit[j][m]!=0):
                for x in range (4):
                    if  (abs(sit[j][m]-ck[1][x])<=20):
                        ff[j][x]=1;  #记录位点m是否出现峰
                        if x==2:
                            sitc[j]=sit[j][m]                    
            if  (ce[j]==3)&(sit[j][m]!=0):
                for x in range (4):
                    if  (abs(sit[j][m]-ck[2][x])<=20):
                        ff[j][x]=1;  #记录位点m是否出现峰 
                        if x==3:
                            sitc[j]=sit[j][m]   
            if  (ce[j]==4)&(sit[j][m]!=0):
                for x in range (4):
                    if  (abs(sit[j][m]-ck[3][x])<=20):
                        ff[j][x]=1;  #记录位点m是否出现峰
                        if x==0:
                            sitc[j]=sit[j][m]  
            if  (ce[j]==5)&(sit[j][m]!=0):
                for x in range (4):
                    if  (abs(sit[j][m]-ck[4][x])<=20):
                        ff[j][x]=1;  #记录位点m是否出现峰
                        if x==2:
                            sitc[j]=sit[j][m] 
                
                
            F[j][1]=sum(ff[j,:]);  #记录总峰数、四个位点峰和 


    # In[13]:


    def findff(j):
        ff[j,:]=0
        p=F[j][0]
        if F[j][0]>7:
            p=7
        for m in range (int(p)): #单双三测 判断C、T1~T3位点是否有峰
            if  (ce[j]==1)&(sit[j][m]!=0):
                for x in range (4):
                    if  (abs(sit[j][m]-ck[0][x])<=20):
                        ff[j][x]=1;  #记录位点m是否出现峰
                        if x==0:
                            sitc[j]=sit[j][m]#记录C线峰坐标
            if  (ce[j]==2)&(sit[j][m]!=0):
                for x in range (4):
                    if  (abs(sit[j][m]-ck[1][x])<=20):
                        ff[j][x]=1;  #记录位点m是否出现峰
                        if x==2:
                            sitc[j]=sit[j][m]                    
            if  (ce[j]==3)&(sit[j][m]!=0):
                for x in range (4):
                    if  (abs(sit[j][m]-ck[2][x])<=20):
                        ff[j][x]=1;  #记录位点m是否出现峰 
                        if x==3:
                            sitc[j]=sit[j][m]   
            if  (ce[j]==4)&(sit[j][m]!=0):
                for x in range (4):
                    if  (abs(sit[j][m]-ck[3][x])<=20):
                        ff[j][x]=1;  #记录位点m是否出现峰
                        if x==0:
                            sitc[j]=sit[j][m]  
            if  (ce[j]==5)&(sit[j][m]!=0):
                for x in range (4):
                    if  (abs(sit[j][m]-ck[4][x])<=20):
                        ff[j][x]=1;  #记录位点m是否出现峰
                        if x==2:
                            sitc[j]=sit[j][m] 
                
            F[j][1]=sum(ff[j,:]);  #记录总峰数、四个位点峰和 


    # In[14]:


    for j in range (curve2_lie):
        
        if F[j][1]==0:#没找到匹配峰，可能是因为测试项目输入错误
            
            cun=ce[j]#暂存ce
            
            if F[j][0]==2:#看看是不是单测
            
                ce[j]=1
                findff(j)
                if F[j][1]!=2:
                    ce[j]=cun
                if F[j][1]==2:
                    cun=ce[j]
                    
                ce[j]=4
                findff(j)
                if F[j][1]!=2:
                    ce[j]=cun
                if F[j][1]==2:
                    cun=ce[j]

                    
            if (F[j][0]==3):
                ce[j]=2
                findff(j)
                if F[j][1]!=3:
                    ce[j]=cun
                if F[j][1]==3:
                    cun=ce[j]
                    
                ce[j]=5
                findff(j)
                if F[j][1]!=3:
                    ce[j]=cun
                if F[j][1]==3:
                    cun=ce[j]

            if F[j][0]>=4:
                ce[j]=3
                findff(j)
                if F[j][1]!=4:
                    ce[j]=cun
                if F[j][1]==4:
                    cun=ce[j]
                    
                ce[j]=5
                findff(j)
                if F[j][1]!=4:
                    ce[j]=cun
                if F[j][1]==4:
                    cun=ce[j]              


    # In[15]:


    #判断有效无效
    true=np.zeros((curve2_lie,1))
    for j in range (curve2_lie):
    ## 关卡判断
        p=ce[j]+1
        if ce[j]==4:
            p=2
        if ce[j]==5:
            p=3

            
        if (F[j][1]<=p)&(F[j][1]>=1)&(F[j][0]<=5): #一定要小于等于7个峰
            reason[j][0]=1;#记录失效原因，1表示通过。第一关卡：峰数匹配。

        if C_ygz[j]>=75: #有效试剂检测
            reason[j][1]=1;#记录失效原因，1表示通过。第二关卡：荧光值匹配。
            
        reason[j][2]=0    
        if (ce[j]!=0) & (abs(ce[j]-xiangmuhao[(Ce[j])])==3) : 
            reason[j][2]=1;#第三关卡：测试项目选错
        if (ce[j]!=0) & (abs(ce[j]-xiangmuhao[(Ce[j])])==0) : 
            reason[j][2]=1;#第三关卡：测试项目选错
    

        #if max(curveToOne2[1:30,j])<curveToOne2[int(sitc[j])][j]:   #左边出现比位点C峰值高的,代码解释：j的测的C的序号的C的位置的曲线数据
        reason[j][3]=1;#第四关卡；曲线要比位点C要低，不然就是未跑完
        
    
        if (ce[j]==1) or (ce[j]==4):
            if sum(curveToOne2[0:int(sit[j][0]-30),j]>0.35)<sit[j][0]-30: 
                reason[j][4]=1;#第五关卡；底线要低，不然就是受潮了,但允许存在先升后降  0~左边第一个峰-30处不能全都大于0.235
            if sum(curveToOne2[320:340,j])<20*0.235:
                reason[j][6]=1;  #尾巴不能高 (第七关) 
        if (ce[j]==2)or (ce[j]==5) :
            if sum(curveToOne2[0:int(sit[j][0]-30),j]>0.5)<sit[j][0]-30: 
                reason[j][4]=1;#第五关卡；底线要低，不然就是受潮了,但允许存在先升后降  0~左边第一个峰-30处不能全都大于0.5
            if sum(curveToOne2[320:340,j])<20*0.5:
                reason[j][6]=1;  #尾巴不能高 (第七关) 
        if (ce[j]==3)  :
            if sum(curveToOne2[0:int(sit[j][0]-30),j]>0.75)<sit[j][0]-30: 
                reason[j][4]=1;#第五关卡；底线要低，不然就是受潮了,但允许存在先升后降  0~左边第一个峰-30处不能全都大于0.75
            if sum(curveToOne2[320:340,j])<20*0.75:
                reason[j][6]=1;  #尾巴不能高 (第七关)   
        k=F[j][0]-1
        if F[j][0]>7:
            k=6
    
    
        if (F[j][1]>1)& (sum(curveToOne2[int(sit[j][0]):int(sit[j][int(k)]),j]>0.5)<0.9*abs(int(sit[j][0])-int(sit[j][int(k)]))):
            reason[j][5]=1;#第六关卡；最左边到最右边的峰之间，不能90%以上的高于0.4
        if (F[j][1]<=1):
            reason[j][5]=1
    
    
        # 纵坐标MAX大于10000 否则是空跑
        reason[j][7]=1;    
        if max(yssj)<=10000:
            reason[j][7]=0;  #空跑
    
    
    ## 有效判断+有效类型判断

        if sum(reason[j])==len(reason[j]): #得分=关卡数（全对）
            true[j]=1; #有效
        
    return int(true)

    # In[16]:


    x=0
    plt.figure(figsize=(10,5))
    plt.xlim(0, 350);
    plt.plot(yssj)
    plt.title(reason[x])


    # In[ ]:




if __name__ == '__main__':

    #数据输入
    # sj=np.array([132148,132106,132119,132144,132209,132302,132345,132332,132307,132242,132145,132074,132026,131977,131963,131979,131989,132022,132064,132105,132147,132216,132271,132352,132408,132450,132448,132422,132327,132216,132052,131859,131621,131364,131053,130722,130383,130023,129639,129251,128855,128433,128026,127637,127257,126900,126580,126276,126008,125774,125576,125405,125266,125136,125033,124932,124826,124709,124585,124444,124321,124209,124120,124036,123967,123871,123775,123669,123577,123479,123400,123338,123288,123247,123222,123219,123211,123219,123237,123275,123308,123374,123441,123522,123607,123702,123784,123863,123931,123981,124023,124042,124045,124020,123979,123908,123817,123701,123565,123402,123217,123023,122808,122575,122322,122063,121762,121458,121139,120822,120492,120179,119862,119574,119291,119020,118764,118522,118260,118005,117756,117511,117264,117035,116808,116595,116385,116180,115969,115766,115541,115316,115098,114893,114671,114465,114235,113986,113719,113459,113197,112965,112742,112536,112344,112170,111998,111874,111793,111758,111788,111926,112173,112596,113253,114201,115507,117253,119475,122256,125664,129747,134561,140173,146569,153746,161679,170247,179334,188818,198511,208198,217759,226994,235718,243764,251010,257247,262369,266236,268804,270001,269868,268384,265676,261770,256810,250878,244185,236831,229015,220884,212605,204313,196148,188247,180702,173628,167058,161094,155716,150947,146753,143122,139952,137223,134832,132738,130853,129138,127515,125988,124504,123062,121653,120285,118953,117678,116456,115306,114236,113254,112355,111564,110846,110220,109655,109155,108682,108281,107904,107571,107251,106977,106695,106427,106171,105945,105722,105543,105387,105261,105165,105120,105105,105167,105310,105570,105968,106566,107390,108502,109976,111910,114422,117633,121691,126726,132868,140238,148946,159091,170750,183957,198709,214958,232546,251290,270943,291157,311597,331901,351622,370326,387610,403020,416163,426771,434616,439578,441656,440920,437454,431443,423070,412559,400165,386186,370906,354651,337712,320405,303018,285851,269176,253270,238341,224583,212148,201088,191421,183097,176003,169934,164742,160220,156203,152571,149230,146098,143124,140274,137479,134750,132069,129481,127001,124674,122556,120673,119001,117573,116378,115373,114537,113859,113289,112833,112448,112133,111877,111662,111464,111306,111165,111018,110885,110727,110523,110250,109931,109499,108976,108326,107543,106538,105327,103848,102079,99965])#输入350个数据点 
    # sj=sj.T
    sj = "93960,93942,93916,93922,93933,93956,93974,93999,93994,93982,93952,93918,93842,93747,93620,93472,93287,93105,92921,92746,92581,92418,92273,92139,92006,91866,91760,91651,91553,91461,91390,91294,91207,91117,91008,90880,90755,90616,90450,90300,90154,90013,89868,89733,89592,89428,89266,89093,88910,88705,88527,88315,88104,87895,87707,87509,87331,87171,87037,86913,86816,86753,86735,86756,86837,86975,87199,87493,87865,88318,88895,89564,90391,91386,92595,94012,95721,97748,100186,103133,106690,110986,116141,122289,129557,138144,148178,159857,173337,188731,206095,225388,246435,268984,292692,317093,341745,366158,389839,412280,433043,451647,467695,480811,490691,497097,499898,499033,494541,486587,475360,461167,444370,425388,404636,382606,359760,336559,313442,290835,269125,248648,229689,212447,197043,183485,171726,161597,152930,145514,139142,133619,128817,124585,120836,117488,114480,111780,109368,107212,105323,103691,102286,101098,100111,99297,98629,98096,97692,97391,97189,97079,97040,97056,97135,97272,97446,97669,97925,98219,98543,98935,99388,99929,100571,101341,102242,103335,104665,106280,108232,110612,113475,116917,121014,125893,131661,138436,146346,155545,166133,178202,191827,206958,223496,241258,259964,279300,298899,318382,337378,355521,372395,387679,401020,412087,420623,426422,429359,429395,426559,420933,412729,402119,389353,374769,358696,341472,323477,305101,286641,268489,250930,234274,218762,204608,191873,180639,170845,162369,155094,148871,143507,138874,134851,131310,128180,125411,122951,120752,118811,117072,115535,114157,112953,111873,110950,110149,109486,108940,108523,108208,107991,107853,107784,107773,107831,107938,108108,108328,108621,108956,109365,109845,110447,111176,112123,113352,114964,117038,119702,123030,127121,132068,137929,144748,152572,161410,171220,181974,193586,205925,218833,232112,245534,258820,271708,283898,295097,305042,313527,320329,325312,328412,329541,328680,325891,321223,314750,306688,297243,286635,275170,263139,250789,238352,226070,214103,202658,191831,181778,172574,164298,156929,150497,144945,140198,136179,132808,129979,127611,125618,123915,122445,121187,120074,119122,118314,117642,117093,116665,116330,116079,115917,115811,115792,115825,115935,116085,116283,116480,116707,116912,117109,117299,117463,117576,117616,117538,117289,116869,116208,115281,114031,112439,110462,108082,105298,102146,98611,"
    #输入关键信息
    C_ygz=15232   ; #荧光值
    Ce=3      ;#项目号
    #读取阴阳性
    res = judge_youxiao(sj, C_ygz, Ce)
    print(res)